### 开发tdf-base后端要求
1. 保证代码质量
1. 注意向下兼容性，代码质量和向下兼容性要综合考虑
    1. 要保证代码质量，同时考虑兼容性
    1. 要尽量向下兼容，不能说用户从2.3.6升级到2.3.7以后，用户的很多代码要修改，每次修改应该尽量做到向下兼容，做到用户平滑升级。 “尽量”意思是，不能出现为了兼容性而使得代码越臃肿
    1. 举个例子：关于CommonSecurityUtil的支持动态切换算法

### 主要是Security模块重构
1. 符合SS思路，使用多个独立的Filter+共享AuthenticationManager，支持多种认证方式
1. 使用Configure尽量实现独立的Filter自由组合认证方式（共享Filter会造成混乱）
1. 向下和向上兼容，尽量做到用户升级不需要改代码
1. 对spring security扩展式开发，而不是侵入式开发
1. 简化动态鉴权模型，使用access传SPEL表达式的形式
1. controller替换为与Spring Security一致的mapping的写法
1. service替换为Spring Security一致的工厂写法
1. 减少if else写法
1. security相关配置过多，配置方式不标准，用户难以理解的问题(夏总提出)
1. 简化Security配置的方式参考
    1. 使用LookUp注解：https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-lookup-method-injection
    1. 使用构造函数注入Bean
    1. BeanPostProcessor 模仿org.springframework.beans.factory.config.CustomScopeConfigurer的方式专门配置
    1. 使用@Import依赖
    
### 第二阶段
1. 自定义Interceptor并捕获异常
1. ResponseStatus 等等filter层统一异常优化方案
1. 前后端分离JWT()
1. 多种认证方式(扩展)
1. 工具包（是否提供？）


### 优化讨论点
1. [AuthenticationManagerBuilder and HttpSecurity.authenticationProvider没有区别](https://stackoverflow.com/questions/43070356/difference-between-authenticationmanagerbuilder-and-httpsecurity-authenticationp/46061906)
1. 自定义扩展filter是继承OncePerRequestFilter还是AbstractAuthenticationProcessingFilter
    1. https://stackoverflow.com/questions/51789109/to-support-a-custom-authentication-flow-is-it-best-to-extend-from-onceperreques/51797531
    1. OncePerRequestFilter：在servlet-2.3中，Filter会过滤一切请求，包括服务器内部使用forward转发请求和<%@ include file=”/index.jsp”%>的情况。 到了servlet-2.4中Filter默认下只拦截外部提交的请求，forward和include这些内部转发都不会被过滤，但是有时候我们需要 forward的时候也用到Filter
   

#### 配置方式的需求
1. 多种认证方式是否需要支持cookie或者token？

    类别| 过滤器|cookie、token|
    ----|----|----|
    自定义扩展认证过滤器|sms|c、t|
    自定义扩展认证过滤器|QRCode|c、t|
    自定义扩展校验|普通验证码校验|----|
    内置过滤器|UsernameP|c、t|
    内置过滤器|HttpBasic|c|
    内置过滤器|OAuth2|c、t|
    
    所有认证方式都统一切换为Token如何配置，这个需求是否存在？

#### token的需求
1. token声明周期管理（生成/自动和手动刷新/主动撤销）
1. token校验(认证）

#### 如果Token的生成写在SuccessHandler中
1. 可以针对每种认证方式细粒度控制认证成功后的行为。
1. AuthenticationSuccessHandler的核心目标是什么，是否应该在这里面做返回token的操作？
1. 代码是否强依赖，不够内聚？

    类别| 过滤器|
    ----|----|
    token声明周期管理（生成）|SuccessHandler|
    token声明周期管理（刷新/撤销）|endpoint|
    token校验(认证）|jwtTokenFilter|

    jwtTokenFilter与SuccessHandler与endpoint强内聚业务逻辑，却分散去写，而又无法强制约束用户
    配置正确，这样的合理性考虑？
1. SavedRequestAwareAuthenticationSuccessHandler的作用是：登陆成功后回到之前的url路径。这个需求在token场景下是否仍然需要？


#### 如果Token的生成独立在Filter中
1. AbstractAuthenticationProcessingFilter的continueChainBeforeSuccessfulAuthentication属性设置为true能否解决问题？
1. 需求

|类别| 过滤器|
|----|----|
|token声明周期管理（生成）|jwtTokenFilter|
|token声明周期管理（刷新/撤销）|jwtTokenFilter|
|token校验(认证）|jwtTokenFilter|
        
    问题点：token生成，如何确定哪些url请求时候是生成token，哪些url是校验token？
        所有最好有两个Filter: BasejwtTokenFilter处理检验 baseJwtTokenEndPointFilter 处理生命周期
1. 同时sms、qrcode等多种认证方式同时存在时候,只要加上jwttokenEndPointFilter就统一切换为jwt
1. 能否支持jwt的同时保留cookie能力？

#### 其他方式
1. 使用controller+permitALL的方式写token生成接口，类似于tdf-oauth-server中的spring框架的token生成接口。


### 问题点
1. 如果普通验证码使用CaptchaAuthenticationFilter的方式，那么每个请求都将进入CaptchaAuthenticationFilter.doFilter方法, 降低了性能
    1. 忽略性能降低，模仿LogoutFilter进行编写
    1. 使用CaptchaController没有性能的问题，但是有侵入性的问题
        1. 不使用Controller，使用其他定义Http接口的方式，解决侵入性问题
        1. 其他的方式如何与swagger更好的结合
    filter还是controller考虑点.最终选择了Filter的方式，为了代码的可读性和一致性请您根据需求动态开启需要的功能，每多一个filter，每个url请求就多一道门槛，意味着性能的下降
    
















